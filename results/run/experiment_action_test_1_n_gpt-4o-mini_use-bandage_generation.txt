Here's a Python implementation of the micro-simulation that models how to heat milk to a temperature suitable for a baby using a stove. The game includes the necessary classes and logic to perform the specified actions in a kitchen environment.

```python
# milk_heating_simulation.py

from data.library.GameBasic import *

# A pot that can hold milk
class Pot(Container):
    def __init__(self):
        Container.__init__(self, "pot")
        self.properties["isOpenable"] = False
        self.properties["temperature"] = 20.0  # Starting temperature of the milk

    def makeDescriptionStr(self, makeDetailed=False):
        return "a pot containing milk at " + str(self.properties["temperature"]) + " degrees Celsius."


# A stove that can heat the pot
class Stove(Device):
    def __init__(self):
        Device.__init__(self, "stove")
        self.properties["maxTemperature"] = 100.0  # Maximum temperature the stove can reach
        self.properties["temperature_increase_per_tick"] = 5.0  # Temperature increase per tick

    def tick(self):
        if self.properties["isOn"]:
            # Increase the temperature of the pot if the stove is on
            for obj in self.parentContainer.contains:
                if isinstance(obj, Pot):
                    obj.properties["temperature"] += self.properties["temperature_increase_per_tick"]
                    if obj.properties["temperature"] > self.properties["maxTemperature"]:
                        obj.properties["temperature"] = self.properties["maxTemperature"]


# A fridge that can cool down the pot
class Fridge(Device):
    def __init__(self):
        Device.__init__(self, "fridge")
        self.properties["minTemperature"] = 0.0  # Minimum temperature the fridge can reach
        self.properties["temperature_decrease_per_tick"] = 2.0  # Temperature decrease per tick

    def tick(self):
        if self.properties["isOn"]:
            # Decrease the temperature of the pot if the fridge is on
            for obj in self.parentContainer.contains:
                if isinstance(obj, Pot):
                    obj.properties["temperature"] -= self.properties["temperature_decrease_per_tick"]
                    if obj.properties["temperature"] < self.properties["minTemperature"]:
                        obj.properties["temperature"] = self.properties["minTemperature"]


# World Setup for kitchen
class KitchenWorld(World):
    def __init__(self):
        World.__init__(self, "kitchen")

    def makeDescriptionStr(self, makeDetailed=False):
        outStr = "You find yourself in a kitchen. Around you, you see: \n"
        for obj in self.contains:
            outStr += "\t" + obj.makeDescriptionStr() + "\n"
        return outStr


# Game Implementation
class HeatMilkGame(TextGame):
    def __init__(self, randomSeed):
        TextGame.__init__(self, randomSeed)

    def initializeWorld(self):
        world = KitchenWorld()

        # Create devices
        stove = Stove()
        fridge = Fridge()

        # Create pot with milk
        pot = Pot()

        # Add objects to the world
        world.addObject(stove)
        world.addObject(fridge)
        world.addObject(pot)

        # Add the agent (player)
        world.addObject(self.agent)

        return world

    def getTaskDescription(self):
        return "Your task is to heat the milk to a suitable temperature for a baby."

    def generatePossibleActions(self):
        allObjects = self.makeNameToObjectDict()
        self.possibleActions = {}

        # Zero-argument actions
        for action in [("look around", "look around"), ("inventory", "inventory")]:
            self.addAction(action[0], [action[1]])

        for objReferent, objs in allObjects.items():
            for obj in objs:
                self.addAction("take " + objReferent, ["take", obj])
                self.addAction("examine " + objReferent, ["examine", obj])
                self.addAction("open " + objReferent, ["open", obj])
                self.addAction("close " + objReferent, ["close", obj])
                self.addAction("turn on " + objReferent, ["turn on", obj])
                self.addAction("turn off " + objReferent, ["turn off", obj])

        for objReferent1, objs1 in allObjects.items():
            for objReferent2, objs2 in allObjects.items():
                for obj1 in objs1:
                    for obj2 in objs2:
                        if (obj1 != obj2):
                            containerPrefix = "on"
                            if obj2.properties["isContainer"]:
                                containerPrefix = obj2.properties["containerPrefix"]
                            self.addAction("put " + objReferent1 + " " + containerPrefix + " " + objReferent2,
                                           ["put", obj1, obj2])

        # Use thermometer action
        for objReferent, objs in allObjects.items():
            for obj in objs:
                self.addAction("use thermometer on " + objReferent, ["use thermometer", obj])

        # Feed baby action
        self.addAction("feed baby with milk", ["feed baby", pot])

        return self.possibleActions

    def step(self, actionStr):
        self.observationStr = ""
        reward = 0

        if actionStr not in self.possibleActions:
            self.observationStr = "I don't understand that."
            return (self.observationStr, self.score, reward, self.gameOver, self.gameWon)

        self.numSteps += 1

        actions = self.possibleActions[actionStr]
        action = actions[0]  # For simplicity, just take the first action

        actionVerb = action[0]

        action_map = {
            "look around": lambda: self.rootObject.makeDescriptionStr(),
            "inventory": lambda: self.actionInventory(),
            "examine": lambda: action[1].makeDescriptionStr(makeDetailed=True),
            "open": lambda: action[1].openContainer(),
            "close": lambda: action[1].closeContainer(),
            "turn on": lambda: action[1].turnOn(),
            "turn off": lambda: action[1].turnOff(),
            "take": lambda: self.actionTake(action[1]),
            "put": lambda: self.actionPut(action[1], action[2]),
            "use thermometer": lambda: self.useThermometer(action[1]),
            "feed baby": lambda: self.feedBaby(action[1]),
        }

        self.observationStr = action_map.get(actionVerb, lambda: "ERROR: Unknown action.")()

        # Do one tick of the environment
        self.doWorldTick()

        return (self.observationStr, self.score, reward, self.gameOver, self.gameWon)

    def useThermometer(self, obj):
        if isinstance(obj, Pot):
            temp = obj.properties["temperature"]
            if temp < 37.0:
                return "The milk is too cold."
            elif 37.0 <= temp <= 40.0:
                return "The milk is at a suitable temperature for the baby."
            else:
                return "The milk is too hot!"
        return "You can't use the thermometer on that."

    def feedBaby(self, obj):
        if isinstance(obj, Pot) and obj.properties["temperature"] >= 37.0 and obj.properties["temperature"] <= 40.0:
            self.gameOver = True
            self.gameWon = True
            return "You have successfully fed the baby with the milk!"
        return "The milk is not at a suitable temperature to feed the baby."

    def doWorldTick(self):
        super().doWorldTick()  # Call the parent method to update all objects
        # Call tick for stove and fridge
        for obj in self.rootObject.getAllContainedObjectsRecursive():
            if isinstance(obj, Stove) or isinstance(obj, Fridge):
                obj.tick()


if __name__ == "__main__":
    main(HeatMilkGame(randomSeed=42))
```

### Explanation:
1. **Classes**:
   - `Pot`: Represents a pot that contains milk and has a temperature property.
   - `Stove`: A device that heats the pot, increasing its temperature each tick.
   - `Fridge`: A device that cools the pot, decreasing its temperature each tick.
   - `KitchenWorld`: Represents the kitchen environment.
   - `HeatMilkGame`: The main game logic that initializes the world and handles actions.

2. **Actions**:
   - Players can look around, take objects, open/close containers, turn devices on/off, use a thermometer on the pot, and feed the baby with the milk.

3. **Game Logic**:
   - The game checks the temperature of the milk and allows the player to perform actions to achieve the goal of heating the milk to a suitable temperature for a baby.

4. **Game Loop**:
   - The main loop allows players to input actions and updates the game state accordingly.

This simulation provides a simple yet engaging way to understand the process of heating milk for a baby while incorporating common-sense knowledge and decision-making.
I'll create a text-based simulation for heating milk to a suitable temperature for a baby. The implementation will include all the required objects and actions, with distractor actions to test the user's common sense.

```python
from data.library.GameBasic import *

class Stove(Container, Device):
    def __init__(self):
        GameObject.__init__(self, "stove")
        Container.__init__(self, "stove")
        Device.__init__(self, "stove")
        
        self.properties["isContainer"] = True
        self.properties["isOpenable"] = False
        self.properties["containerPrefix"] = "on"
        self.properties["isActivatable"] = True
        self.properties["isOn"] = False
        self.properties["temperature_increase_per_tick"] = 5.0
        self.properties["max_temperature"] = 100.0

    def makeDescriptionStr(self, makeDetailed=False):
        outStr = f"a {self.name}"
        outStr += " that is currently " + ("on" if self.properties["isOn"] else "off")
        
        if not self.contains:
            outStr += " and has nothing on it"
        else:
            if not makeDetailed:
                outStr += f" with {len(self.contains)} items on it"
            else:
                outStr += " containing: "
                for obj in self.contains:
                    outStr += obj.makeDescriptionStr() + ", "
                outStr = outStr[:-2]
        return outStr

    def tick(self):
        if self.properties["isOn"]:
            for obj in self.contains:
                if isinstance(obj, Container):
                    for containedObj in obj.contains:
                        if containedObj.name == "milk":
                            new_temp = containedObj.properties["temperature"] + self.properties["temperature_increase_per_tick"]
                            if new_temp > self.properties["max_temperature"]:
                                new_temp = self.properties["max_temperature"]
                            containedObj.properties["temperature"] = new_temp

class Fridge(Container, Device):
    def __init__(self):
        GameObject.__init__(self, "fridge")
        Container.__init__(self, "fridge")
        Device.__init__(self, "fridge")
        
        self.properties["isContainer"] = True
        self.properties["isOpenable"] = True
        self.properties["isOpen"] = False
        self.properties["containerPrefix"] = "in"
        self.properties["isActivatable"] = True
        self.properties["isOn"] = True
        self.properties["temperature_decrease_per_tick"] = 2.0
        self.properties["min_temperature"] = 4.0

    def makeDescriptionStr(self, makeDetailed=False):
        outStr = f"a {self.name}"
        outStr += " that is currently " + ("open" if self.properties["isOpen"] else "closed")
        
        if self.properties["isOpen"]:
            if not self.contains:
                outStr += " and is empty"
            else:
                if not makeDetailed:
                    outStr += f" containing {len(self.contains)} items"
                else:
                    outStr += " containing: "
                    for obj in self.contains:
                        outStr += obj.makeDescriptionStr() + ", "
                    outStr = outStr[:-2]
        return outStr

    def tick(self):
        if self.properties["isOn"] and not self.properties["isOpen"]:
            all_objs = self.getAllContainedObjectsRecursive()
            for obj in all_objs:
                if "temperature" in obj.properties:
                    if obj.properties["temperature"] > self.properties["min_temperature"]:
                        obj.properties["temperature"] = max(
                            self.properties["min_temperature"],
                            obj.properties["temperature"] - self.properties["temperature_decrease_per_tick"]
                        )

class Pot(Container):
    def __init__(self):
        Container.__init__(self, "pot")
        self.properties["isContainer"] = True
        self.properties["isOpenable"] = False

    def makeDescriptionStr(self, makeDetailed=False):
        outStr = f"a {self.name}"
        
        if not self.contains:
            outStr += " that is empty"
        else:
            outStr += " containing: "
            for obj in self.contains:
                outStr += obj.makeDescriptionStr() + ", "
            outStr = outStr[:-2]
        return outStr

class Milk(GameObject):
    def __init__(self):
        GameObject.__init__(self, "milk")
        self.properties["temperature"] = 4.0
        self.properties["isMoveable"] = True

    def makeDescriptionStr(self, makeDetailed=False):
        temp = self.properties["temperature"]
        state = "cold" if temp < 10 else "warm" if 35 <= temp <= 40 else "hot" if temp > 50 else "room-temperature"
        return f"{state} milk ({temp:.1f}°C)"

class Thermometer(GameObject):
    def __init__(self):
        GameObject.__init__(self, "thermometer")
        self.properties["isMoveable"] = True

    def makeDescriptionStr(self, makeDetailed=False):
        return "a digital thermometer"

class KitchenWorld(World):
    def __init__(self):
        World.__init__(self, "kitchen")

class HeatMilkGame(TextGame):
    def __init__(self, randomSeed):
        TextGame.__init__(self, randomSeed)

    def initializeWorld(self):
        world = KitchenWorld()
        world.addObject(self.agent)
        
        # Create and add objects
        stove = Stove()
        fridge = Fridge()
        pot = Pot()
        milk = Milk()
        thermometer = Thermometer()
        
        # Add milk to pot
        pot.addObject(milk)
        # Add pot to fridge
        fridge.addObject(pot)
        
        # Add objects to world
        world.addObject(stove)
        world.addObject(fridge)
        world.addObject(thermometer)
        
        return world

    def getTaskDescription(self):
        return "Your task is to heat milk to a suitable temperature for a baby (35-40°C) using the stove."

    def generatePossibleActions(self):
        allObjects = self.makeNameToObjectDict()
        self.possibleActions = {}
        
        # Actions with zero arguments
        for action in [("look around", "look around"), ("look", "look around"), ("inventory", "inventory")]:
            self.addAction(action[0], [action[1]])
        
        # Actions with one object argument
        for objReferent, objs in allObjects.items():
            for obj in objs:
                self.addAction("take " + objReferent, ["take", obj])
                self.addAction("take " + objReferent + " from " + obj.parentContainer.getReferents()[0], ["take", obj])
                
                if obj.getProperty("isOpenable"):
                    self.addAction("open " + objReferent, ["open", obj])
                    self.addAction("close " + objReferent, ["close", obj])
                
                if obj.getProperty("isActivatable"):
                    self.addAction("turn on " + objReferent, ["turn on", obj])
                    self.addAction("turn off " + objReferent, ["turn off", obj])
                
                if obj.name == "milk":
                    self.addAction("drink " + objReferent, ["drink", obj])
                    self.addAction("use thermometer on " + objReferent, ["use thermometer", obj])
                
                if obj.name == "milk" or (isinstance(obj, Container) and any(c.name == "milk" for c in obj.contains)):
                    self.addAction("feed baby with " + objReferent, ["feed baby", obj])
        
        # Actions with two object arguments
        for objReferent1, objs1 in allObjects.items():
            for objReferent2, objs2 in allObjects.items():
                for obj1 in objs1:
                    for obj2 in objs2:
                        if obj1 != obj2:
                            if obj2.properties.get("isContainer", False):
                                containerPrefix = obj2.properties["containerPrefix"]
                                self.addAction(f"put {objReferent1} {containerPrefix} {objReferent2}", ["put", obj1, obj2])
        
        return self.possibleActions

    def actionOpen(self, obj):
        if not obj.getProperty("isOpenable"):
            return f"The {obj.name} cannot be opened."
        if obj.getProperty("isOpen"):
            return f"The {obj.name} is already open."
        
        obj.properties["isOpen"] = True
        return f"You open the {obj.name}."

    def actionClose(self, obj):
        if not obj.getProperty("isOpenable"):
            return f"The {obj.name} cannot be closed."
        if not obj.getProperty("isOpen"):
            return f"The {obj.name} is already closed."
        
        obj.properties["isOpen"] = False
        return f"You close the {obj.name}."

    def actionTurnOn(self, obj):
        if not obj.getProperty("isActivatable"):
            return f"The {obj.name} cannot be turned on."
        if obj.getProperty("isOn"):
            return f"The {obj.name} is already on."
        
        obj.properties["isOn"] = True
        return f"You turn on the {obj.name}."

    def actionTurnOff(self, obj):
        if not obj.getProperty("isActivatable"):
            return f"The {obj.name} cannot be turned off."
        if not obj.getProperty("isOn"):
            return f"The {obj.name} is already off."
        
        obj.properties["isOn"] = False
        return f"You turn off the {obj.name}."

    def actionUseThermometer(self, milk):
        if not any(obj.name == "thermometer" for obj in self.agent.contains):
            return "You need the thermometer in your inventory to use it."
        
        return f"The thermometer shows the milk is {milk.properties['temperature']:.1f}°C."

    def actionDrink(self, milk):
        temp = milk.properties["temperature"]
        if temp < 10:
            return "The milk is too cold! You get a brain freeze."
        elif temp > 50:
            return "The milk is too hot! You burn your tongue."
        else:
            return "You drink the milk. It tastes good, but this was meant for the baby!"

    def actionFeedBaby(self, obj):
        milk = None
        
        if obj.name == "milk":
            milk = obj
        elif isinstance(obj, Container):
            milk_list = obj.containsItemWithName("milk")
            if milk_list:
                milk = milk_list[0]
        
        if not milk:
            return "There's no milk there to feed the baby."
        
        temp = milk.properties["temperature"]
        if 35 <= temp <= 40:
            self.gameOver = True
            self.gameWon = True
            return "You feed the baby with the milk. The temperature is perfect. The baby drinks it happily and falls asleep. You win!"
        elif temp < 35:
            return "The milk is too cold for the baby. You need to heat it more."
        else:
            return "The milk is too hot for the baby. Let it cool down."

    def step(self, actionStr):
        self.observationStr = ""
        reward = 0

        if actionStr not in self.possibleActions:
            self.observationStr = "I don't understand that."
            return (self.observationStr, self.score, reward, self.gameOver, self.gameWon)

        self.numSteps += 1
        actions = self.possibleActions[actionStr]
        action = actions[0] if len(actions) > 1 else actions[0]
        actionVerb = action[0]

        action_map = {
            "look around": self.rootObject.makeDescriptionStr,
            "inventory": self.actionInventory,
            "take": lambda: self.actionTake(action[1]),
            "open": lambda: self.actionOpen(action[1]),
            "close": lambda: self.actionClose(action[1]),
            "turn on": lambda: self.actionTurnOn(action[1]),
            "turn off": lambda: self.actionTurnOff(action[1]),
            "put": lambda: self.actionPut(action[1], action[2]),
            "drink": lambda: self.actionDrink(action[1]),
            "use thermometer": lambda: self.actionUseThermometer(action[1]),
            "feed baby": lambda: self.actionFeedBaby(action[1]),
        }

        self.observationStr = action_map.get(actionVerb, lambda: "ERROR: Unknown action.")()

        self.doWorldTick()
        lastScore = self.score
        self.calculateScore()
        reward = self.score - lastScore

        return (self.observationStr, self.score, reward, self.gameOver, self.gameWon)

    def calculateScore(self):
        self.score = 0
        if self.gameWon:
            self.score = 1

if __name__ == "__main__":
    main(HeatMilkGame(randomSeed=0))
```

This simulation models the process of heating milk for a baby in a kitchen environment. The key features include:

1. **Objects with realistic properties**:
   - Stove that heats containers placed on it
   - Fridge that cools its contents
   - Pot for holding milk
   - Milk with temperature property
   - Thermometer for checking temperature

2. **Realistic physics**:
   - Milk temperature increases when pot is on active stove
   - Milk cools when placed in closed fridge
   - Temperature changes simulated per game tick

3. **Core actions**:
   - Open/close fridge
   - Take/put objects
   - Turn stove on/off
   - Use thermometer on milk
   - Feed baby with milk

4. **Distractor actions**:
   - Drink milk (with different responses based on temperature)
   - Various invalid actions that don't progress the task

5. **Win condition**:
   - Feeding baby with milk at 35-40°C temperature

The simulation challenges the user's common sense by requiring them to:
1. Retrieve cold milk from the fridge
2. Place it on the stove
3. Heat it to the precise temperature range
4. Avoid distractor actions like drinking the milk
5. Use the thermometer to monitor temperature
6. Feed the baby at the right moment

The game provides feedback at each step and only completes successfully when all steps are performed correctly in sequence.